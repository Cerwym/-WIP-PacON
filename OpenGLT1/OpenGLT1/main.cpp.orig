#define WIN32_WIND

#include <Windows.h>

#include "SDL.h"
#include "SDL_opengl.h"
#include "OpenGLSys.h"
#include "timer.h"

HDC hDC;				// Private GDI Device Context
bool active=true;		// Window Active Flag
bool fullscreen=false;	// Fullscreen Flag

// Ugly stuff
long wWidth = 800;
long wHeight = 600;
long wBits = 32;

OpenGLSys *glRender = NULL;
CHiResTimer *g_hiResTimer = NULL;
SDL_Surface *surface;

<<<<<<< HEAD
<<<<<<< HEAD
void ShutDown()
{
	delete glRender;
	delete g_hiResTimer;
	if (fullscreen)
	{
		ChangeDisplaySettings(NULL, 0);
		ShowCursor(true);
	}
}
void SetupPixelFormat(HDC hDC)
=======
void Quit( int code)
>>>>>>> 1ad1791e53d611525d7d2e8ae25d3e7e369e2cdb
{
	// Clean up the window
	SDL_Quit();
	delete glRender;
	delete g_hiResTimer;
	exit(code);
}
=======
void Quit( int code)
{
	// Clean up the window
	SDL_Quit();
	delete glRender;
	delete g_hiResTimer;
	exit(code);
}
>>>>>>> origin/master
void handleMainKeyPress(SDL_keysym *keysym)
{
	switch(keysym->sym)
	{
	case SDLK_ESCAPE:
		Quit(0);
		break;
	case SDLK_F1:
		// Toggle fullscreen
		SDL_WM_ToggleFullScreen(surface);
		break;
	default:
		break;
	}
}

int main(int argc, char **argv)
{
	int vidFlags;				// Flags to pass to SDL_SetVideoMode
	bool gLoop = true;			// Game loop boolean
	SDL_Event event;			// Event collection
	const SDL_VideoInfo *vidInfo; // Display information
	bool wndIsActive = true;	// Is the Window active?

	glRender = new OpenGLSys;
	g_hiResTimer = new CHiResTimer;

	// Init SDL
	if (SDL_Init(SDL_INIT_VIDEO) < 0)
	{
		fprintf(stderr, "Failed to initialize SDL: %s\n", SDL_GetError());
		Quit(1);
	}

	SDL_WM_SetCaption("Pete's Little App", NULL);

	// Fetch card info
	vidInfo = SDL_GetVideoInfo();
	if (!vidInfo)
	{
		fprintf(stderr, "Failed to get video info: %s\n", SDL_GetError());
		Quit(1);
	}

<<<<<<< HEAD
<<<<<<< HEAD
	AdjustWindowRectEx(&windowRect, dwStyle, false, dwExStyle); // And adjust window to the REQUESTED size
	if (!(hWnd=CreateWindowEx(  dwExStyle,
		"POpenGLApp",							// Class Name
		"Pete's Little App",					// Window Title
		WS_CLIPSIBLINGS |						// Required Window Style
		WS_CLIPCHILDREN |						// Required Window Style
		dwStyle,								// Selected Window Style
		0, 0,									// Window Position
		windowRect.right-windowRect.left,		// Calculate Adjusted Window Width
		windowRect.bottom-windowRect.top,		// Calculate Adjusted Window Height
		NULL,									// No Parent Window
		NULL,									// No Menu
		hInstance,								// Instance
		NULL)))									// Don't Pass Anything To WM_CREATE
=======
=======
>>>>>>> origin/master
	vidFlags	=	SDL_OPENGL;	// Enables OpenGL in SDL
	vidFlags	|=	SDL_GL_DOUBLEBUFFER;	// Enable double buffering
	vidFlags	|=	SDL_HWPALETTE;			// Store the palette in hardware
	vidFlags	|=	SDL_RESIZABLE;			// Enable window resizing
	// Check to see if surfaces can be stored in memory
	if (vidInfo->hw_available)	vidFlags |= SDL_HWSURFACE;
	else	vidFlags	|=	SDL_SWSURFACE;
	// Check if H/W blits can be done
	if (vidInfo->blit_hw)	vidFlags	|=	SDL_HWACCEL;

	// Setup OpenGL double buffering
	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

	// Get an SDL surface
	surface = SDL_SetVideoMode(wWidth, wHeight, wBits, vidFlags);
	if (!surface)
<<<<<<< HEAD
>>>>>>> 1ad1791e53d611525d7d2e8ae25d3e7e369e2cdb
=======
>>>>>>> origin/master
	{
		fprintf(stderr, "Video mode set failed: %s \n", SDL_GetError());
		return false;
	}

	glRender->Init();
	glRender->SetProjection(wWidth, wHeight);

	// Init the timer that will 'limit' the framerate and help the program deal with updates based on time rather than frames elapsed
	g_hiResTimer->Init();

	while (active)
	{
		// Handle events in the queue
		while (SDL_PollEvent(&event))
		{
			switch(event.type)
			{
			case SDL_VIDEORESIZE:
				// Handle resize event
				surface = SDL_SetVideoMode(event.resize.w, event.resize.h, wBits, vidFlags);
				if (!surface)
				{
					fprintf(stderr, "Error resizing surface: %s\n", SDL_GetError());
					return false;
				}
				glRender->SetProjection(event.resize.w, event.resize.h);
				break;
			case SDL_KEYDOWN:
				handleMainKeyPress(&event.key.keysym);
				break;
			case SDL_QUIT:
				active = false;
				break;
			default:
				break;
			}
		}
		if (wndIsActive)
		{
			glRender->Update(g_hiResTimer->GetElapsedSeconds(1));
			glRender->Render();
			SDL_GL_SwapBuffers();
		}
	}
<<<<<<< HEAD
<<<<<<< HEAD
	
	// Shutdown control path
	ShutDown();
	return 0; // Won't be reached
=======
=======
>>>>>>> origin/master

	// Clean up & exit
	Quit(0);
	return 0;

<<<<<<< HEAD
>>>>>>> 1ad1791e53d611525d7d2e8ae25d3e7e369e2cdb
=======
>>>>>>> origin/master
}